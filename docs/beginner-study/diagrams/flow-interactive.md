# 🎨 인터랙티브 흐름 다이어그램

이 문서는 **ASCII 아트**로 그린 흐름도를 제공합니다.

코드가 어떻게 흐르는지 **한눈에** 볼 수 있어요!

---

## 🎬 시나리오 1: 페이지 로딩 흐름

### 전체 흐름도

```
┌─────────────────────────────────────────────────────────────┐
│  👤 사용자가 브라우저 주소창에 입력                          │
│  http://localhost:3000/trm/target-products                  │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🚪 Next.js Router (Next.js 내부)                           │
│  💭 "이 경로는 어느 page.tsx를 실행할까?"                   │
│  📁 찾은 파일: src/app/trm/target-products/page.tsx        │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  📄 page.tsx (Server Component)                             │
│  📍 파일: src/app/trm/target-products/page.tsx             │
│  🏷️ 실행 환경: 서버                                         │
│  📝 코드: const products = await serverFetch(...)           │
│  💭 "데이터를 가져와야겠어!"                                 │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  📞 serverFetch 유틸리티                                     │
│  📍 파일: src/lib/utils/serverFetch.ts                      │
│  📝 요청: GET http://localhost:3000/api/target-products     │
│  💭 "내부 API를 호출하자!"                                   │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🛣️ API Route - GET Handler                                 │
│  📍 파일: src/app/api/target-products/route.ts             │
│  🏷️ 실행 환경: 서버                                         │
│  📝 코드: const products = await targetProductService...    │
│  💭 "Service에서 데이터를 가져오자!"                         │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  ⚙️ Service Layer                                           │
│  📍 파일: src/lib/services/targetProduct.service.ts         │
│  📝 메서드: findAll()                                        │
│  💭 "Prisma로 DB에서 데이터를 가져오자!"                     │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🗄️ Prisma ORM                                              │
│  📝 쿼리: SELECT * FROM target_product...                    │
│  💭 "SQL을 실행해서 데이터를 가져오자!"                      │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  💾 Database (PostgreSQL / MySQL)                           │
│  📊 실제 데이터 반환                                         │
│  📦 [{id: 1, name: "제품A"}, {id: 2, name: "제품B"}, ...]   │
└─────────────────────────────────────────────────────────────┘
                        ↓
                  ⬅️ 응답이 역순으로 돌아감 ⬅️
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🔄 데이터 흐름 (역순)                                       │
│                                                             │
│  Database                                                   │
│    ↓ 쿼리 결과                                              │
│  Prisma                                                     │
│    ↓ 결과 반환                                              │
│  Service                                                    │
│    ↓ DTO로 변환해서 반환                                    │
│  API Route                                                  │
│    ↓ JSON 응답 { success: true, data: [...] }              │
│  serverFetch                                                │
│    ↓ data 부분만 추출                                       │
│  page.tsx                                                   │
│    ↓ products 변수에 저장                                   │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🎨 page.tsx가 HTML 생성                                    │
│  📝 코드: <TargetProductList initialData={products} />      │
│  💭 "Client Component에 데이터를 전달하자!"                  │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  📦 서버가 브라우저에 전송                                   │
│  ✅ HTML (완성된 구조)                                       │
│  ✅ CSS (스타일)                                             │
│  ✅ JavaScript (상호작용 로직)                               │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🖥️ 브라우저가 처리                                          │
│  1️⃣ HTML 렌더링 → 화면에 그리기                             │
│  2️⃣ Hydration → JavaScript 연결 (버튼 작동 가능)            │
│  3️⃣ React가 제어권 획득                                     │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  ✅ 완료!                                                    │
│  👀 사용자가 화면에서 제품 목록을 봅니다                     │
│  🖱️ 버튼 클릭이 가능해집니다                                 │
└─────────────────────────────────────────────────────────────┘
```

### ⏱️ 타임라인

```
시간축 →

0초                0.2초              0.5초              1초
│                  │                  │                  │
├─ 사용자 요청      │                  │                  │
│                  │                  │                  │
├─ Router 찾기     │                  │                  │
│                  │                  │                  │
├─ page.tsx 실행   │                  │                  │
│                  │                  │                  │
├─ serverFetch     ├─ API 호출        │                  │
│                  │                  │                  │
│                  ├─ Service 실행    │                  │
│                  │                  │                  │
│                  ├─ Prisma 쿼리     ├─ DB 응답         │
│                  │                  │                  │
│                  │                  ├─ DTO 변환        │
│                  │                  │                  │
│                  │                  ├─ API 응답        │
│                  │                  │                  │
│                  │                  ├─ HTML 생성       │
│                  │                  │                  │
│                  │                  │                  ├─ 브라우저 렌더링
│                  │                  │                  │
│                  │                  │                  ├─ Hydration 완료
│                  │                  │                  │
│                  │                  │                  ✅ 사용자가 화면 봄!

총 소요 시간: 약 1초 이내
```

---

## 🎬 시나리오 2: 삭제 버튼 클릭 흐름

### 전체 흐름도

```
┌─────────────────────────────────────────────────────────────┐
│  👆 사용자가 테이블에서 "삭제" 버튼 클릭                     │
│  🖱️ 마우스 클릭 이벤트 발생                                  │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🖥️ Client Component - 이벤트 핸들러                         │
│  📍 파일: src/components/.../TargetProductList.tsx          │
│  🏷️ 실행 환경: 브라우저                                      │
│  📝 코드: onClick={() => handleDelete(product)}             │
│  💬 confirm("정말 삭제하시겠습니까?")                        │
└─────────────────────────────────────────────────────────────┘
                        ↓
              사용자가 "확인" 클릭?
                    /    \
                 예 /      \ 아니오
                   /        \
                  ↓          ↓
           계속 진행     함수 종료 (취소)
                  ↓
┌─────────────────────────────────────────────────────────────┐
│  ⚡ 낙관적 업데이트 (Optimistic Update)                      │
│  📍 파일: src/lib/hooks/useOptimisticDelete.ts              │
│  📝 코드: setItems(prev => prev.filter(...))                │
│  💭 "먼저 UI에서 제거하자! (서버 응답 기다리지 않기)"        │
│  ⏰ 타이밍: 즉시! (0.01초)                                   │
└─────────────────────────────────────────────────────────────┘
                        ↓
              👀 사용자가 보는 것:
              "항목이 화면에서 사라짐!" (빠름!)
                        ↓
        (동시에 백그라운드에서 실행)
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  📡 DELETE 요청 보냄 (fetch)                                 │
│  📝 요청: DELETE /api/target-products/123                    │
│  ⏰ 타이밍: 백그라운드 (약 1초)                              │
│  💭 "서버에 실제 삭제 요청을 보내자!"                        │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🛣️ API Route - DELETE Handler                              │
│  📍 파일: src/app/api/target-products/[id]/route.ts        │
│  🏷️ 실행 환경: 서버                                         │
│  📝 코드: await targetProductService.delete(id)             │
│  💭 "Service에 삭제 요청을 전달하자!"                        │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  ⚙️ Service Layer                                           │
│  📍 파일: src/lib/services/targetProduct.service.ts         │
│  📝 메서드: delete(id)                                       │
│  💭 "먼저 존재하는지 확인하고, 있으면 삭제하자!"             │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🗄️ Prisma ORM                                              │
│  📝 쿼리 1: SELECT * FROM ... WHERE id = 123 (존재 확인)     │
│  📝 쿼리 2: DELETE FROM ... WHERE id = 123                   │
│  💭 "데이터베이스에서 실제로 삭제하자!"                      │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  💾 Database                                                │
│  ✅ DELETE 실행 완료                                         │
│  📊 실제 데이터가 삭제되었습니다!                            │
└─────────────────────────────────────────────────────────────┘
                        ↓
                  ⬅️ 응답이 역순으로 돌아감 ⬅️
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  🔄 응답 흐름 (역순)                                         │
│                                                             │
│  Database → Prisma → Service → API Route → 브라우저         │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  ✅ 성공 또는 ❌ 실패 처리                                    │
│                                                             │
│  ✅ 성공한 경우:                                             │
│    - alert("삭제되었습니다")                                 │
│    - UI는 이미 업데이트됨 (Step 3에서)                       │
│    - 아무것도 안 해도 됨!                                    │
│                                                             │
│  ❌ 실패한 경우:                                             │
│    - alert("삭제 실패: " + error)                           │
│    - router.refresh() 호출                                  │
│    - 서버에서 최신 데이터 다시 가져옴                        │
│    - 삭제했던 항목이 다시 나타남 (복구)                      │
└─────────────────────────────────────────────────────────────┘
```

### ⏱️ 타임라인 비교

#### 일반적인 방법 (낙관적 업데이트 없이)
```
시간축 →

0초                0.5초              1초
│                  │                  │
├─ 버튼 클릭        │                  │
│                  │                  │
├─ 로딩 스피너 표시 │                  │
│  ⏳ 사용자 기다림  │                  │
│                  │                  │
│                  ├─ 서버 처리 중     │
│                  │                  │
│                  │                  ├─ 응답 받음
│                  │                  │
│                  │                  ├─ UI 업데이트
│                  │                  │
│                  │                  ✅ 완료 (1초 후)

사용자 경험: "느리다... 기다려야 해..." 😕
```

#### 낙관적 업데이트 방법 (현재 프로젝트)
```
시간축 →

0초                0.5초              1초
│                  │                  │
├─ 버튼 클릭        │                  │
│                  │                  │
├─ 즉시 UI 업데이트│                  │
│  ⚡ (0.01초)      │                  │
│                  │                  │
✅ 사용자: "완료!"  │                  │
   (빠르다! 😊)     │                  │
│                  │                  │
│  (백그라운드)    ├─ 서버 처리 중     │
│                  │                  │
│                  │                  ├─ 응답 받음
│                  │                  │
│                  │                  ✅ 서버도 완료

사용자 경험: "빠르다! 즉시 반응해!" 😊
```

### 🎯 차이점 요약

| 항목 | 일반 방법 | 낙관적 업데이트 |
|------|----------|----------------|
| **사용자가 기다리는 시간** | 약 1초 | 0.01초 |
| **체감 속도** | 느림 😕 | 매우 빠름 😊 |
| **로딩 스피너** | 필요 ⏳ | 불필요 ⚡ |
| **실패 시 처리** | 에러 메시지만 | 복구 로직 필요 |
| **구현 복잡도** | 간단 | 약간 복잡 |
| **사용자 경험** | 보통 | 우수 ⭐⭐⭐ |

---

## 🔄 데이터 흐름 종합

### 페이지 로딩 (서버 → 클라이언트)

```
┌──────────┐
│ Database │  "데이터 창고"
└────┬─────┘
     ↓ 쿼리 결과
┌────┴─────┐
│ Prisma   │  "창고 관리자"
└────┬─────┘
     ↓ 데이터
┌────┴─────┐
│ Service  │  "셰프" (DTO로 조리)
└────┬─────┘
     ↓ 완성된 데이터
┌────┴─────┐
│ API      │  "서빙 직원"
└────┬─────┘
     ↓ JSON 응답
┌────┴─────────┐
│ serverFetch  │  "주문 전달"
└────┬─────────┘
     ↓ data 추출
┌────┴─────┐
│ page.tsx │  "테이블 세팅" (Server Component)
└────┬─────┘
     ↓ Props 전달
┌────┴──────────┐
│ Client Comp.  │  "손님 테이블" (화면 표시)
└───────────────┘
```

### 사용자 인터랙션 (클라이언트 → 서버)

```
┌───────────────┐
│ 사용자 클릭    │
└────┬──────────┘
     ↓ 이벤트
┌────┴──────────┐
│ Client Comp.  │  "손님이 주문"
└────┬──────────┘
     ↓ fetch 호출
┌────┴─────┐
│ API      │  "주문서 접수"
└────┬─────┘
     ↓ Service 호출
┌────┴─────┐
│ Service  │  "주방에서 처리"
└────┬─────┘
     ↓ Prisma 쿼리
┌────┴─────┐
│ Prisma   │  "재료 가져오기"
└────┬─────┘
     ↓ 쿼리 실행
┌────┴─────┐
│ Database │  "재료 창고"
└────┬─────┘
     ↓ 응답 역순
┌────┴──────────┐
│ Client Comp.  │  "손님이 받음"
└───────────────┘
```

---

## 💡 이 다이어그램 활용법

### 📖 학습할 때
```
1. 코드 흐름 추적
   - 각 상자를 하나씩 따라가기
   - 실제 파일을 열어서 코드 확인

2. 실행 순서 이해
   - 화살표 방향 따라가기
   - 역순 흐름도 주의 깊게 보기

3. 타이밍 파악
   - 타임라인 다이어그램 참고
   - 어느 단계가 오래 걸리는지 확인
```

### 🐛 디버깅할 때
```
1. 에러 위치 찾기
   - 다이어그램에서 해당 계층 찾기
   - 그 계층의 파일 확인

2. 데이터 추적
   - console.log를 각 상자에 추가
   - 데이터가 어디서 변경되는지 확인

3. 흐름 검증
   - 실제 실행 순서가 다이어그램과 일치하는지
   - Network 탭으로 API 호출 확인
```

### 🎯 설명할 때
```
1. 누군가에게 설명할 때
   - 이 다이어그램을 보여주기
   - 화살표를 따라 설명

2. 프레젠테이션할 때
   - ASCII 아트를 슬라이드에 포함
   - 각 단계를 애니메이션으로 표시

3. 문서화할 때
   - README에 링크 추가
   - 새 팀원 온보딩 자료로 활용
```

---

## 🎓 다음 단계

흐름도를 이해했다면, 이제 **프로젝트 구조 지도**를 봅시다!

전체 파일이 어떻게 구성되어 있는지 한눈에 볼 수 있어요.

```
📍 다음 단계: visual-guide/architecture-map.md
```
